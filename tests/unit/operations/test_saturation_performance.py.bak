"""Performance tests for saturation GPU/Metal acceleration (Mac only)."""

import platform
import time

import numpy as np
import pytest
from PIL import Image
from sevenrad_stills.operations.saturation import SaturationOperation
from sevenrad_stills.operations.saturation_gpu import SaturationGPUOperation

# Import Metal operation only on macOS
if platform.system() == "Darwin":
    from sevenrad_stills.operations.saturation_metal import SaturationMetalOperation


@pytest.mark.skipif(
    platform.system() != "Darwin",
    reason="GPU/Metal performance tests only run on Mac",
)
class TestSaturationPerformance:
    """Performance tests comparing CPU, GPU, and Metal implementations."""

    @pytest.fixture
    def large_image(self) -> Image.Image:
        """Create a large test image for performance testing."""
        # Use realistic dimensions for photo processing
        return Image.new("RGB", (2048, 2048), color=(100, 150, 200))

    @pytest.fixture
    def xlarge_image(self) -> Image.Image:
        """Create an extra-large test image for stress testing."""
        return Image.new("RGB", (4096, 2048), color=(100, 150, 200))

    def benchmark_operation(
        self,
        operation: SaturationOperation
        | SaturationGPUOperation
        | SaturationMetalOperation,
        image: Image.Image,
        params: dict,
        iterations: int = 5,
    ) -> float:
        """
        Benchmark an operation.

        Args:
            operation: Operation to benchmark
            image: Test image
            params: Operation parameters
            iterations: Number of iterations

        Returns:
            Mean time in milliseconds

        """
        # Warmup (important for GPU/Metal to initialize)
        operation.apply(image, params)
        operation.apply(image, params)

        # Benchmark
        times = []
        for _ in range(iterations):
            start = time.perf_counter()
            operation.apply(image, params)
            end = time.perf_counter()
            times.append((end - start) * 1000)

        return float(np.mean(times))

    def test_gpu_performance_characteristics(self, large_image: Image.Image) -> None:
        """
        Test GPU performance and verify it works correctly.

        Note: For this simple weighted blend operation, PIL's optimized C
        implementation (likely using SIMD) is faster than GPU due to memory
        transfer overhead. GPU acceleration would benefit from:
        - Much larger images (>8K resolution)
        - Batch processing multiple images
        - Integration into pipelines with other GPU operations

        This test verifies GPU works correctly and documents performance.
        """
        cpu_op = SaturationOperation()
        gpu_op = SaturationGPUOperation()

        params = {"mode": "fixed", "value": 0.5}

        cpu_time = self.benchmark_operation(cpu_op, large_image, params)
        gpu_time = self.benchmark_operation(gpu_op, large_image, params)

        speedup = cpu_time / gpu_time

        print(
            f"\nCPU: {cpu_time:.2f}ms, GPU: {gpu_time:.2f}ms, " f"Ratio: {speedup:.2f}x"
        )
        print(
            "Note: PIL's optimized C code is faster for this simple operation. "
            "GPU benefits appear with larger images or batch processing."
        )

        # Just verify GPU produces results (performance verified separately)
        assert gpu_time > 0, "GPU operation should complete"

    def test_metal_faster_than_gpu(self, large_image: Image.Image) -> None:
        """Test that Metal is faster than GPU."""
        gpu_op = SaturationGPUOperation()
        metal_op = SaturationMetalOperation()

        params = {"mode": "fixed", "value": 0.5}

        gpu_time = self.benchmark_operation(gpu_op, large_image, params)
        metal_time = self.benchmark_operation(metal_op, large_image, params)

        speedup = gpu_time / metal_time

        print(
            f"\nGPU: {gpu_time:.2f}ms, Metal: {metal_time:.2f}ms, "
            f"Speedup: {speedup:.2f}x"
        )

        # Metal should be competitive with GPU
        assert speedup > 0.9, (
            f"Metal ({metal_time:.2f}ms) should not be slower than "
            f"GPU ({gpu_time:.2f}ms), got {speedup:.2f}x"
        )

    def test_metal_performance_characteristics(self, large_image: Image.Image) -> None:
        """
        Test Metal performance and verify it works correctly.

        Note: Similar to GPU, PIL's optimized implementation is faster for this
        simple operation due to memory transfer overhead.
        """
        cpu_op = SaturationOperation()
        metal_op = SaturationMetalOperation()

        params = {"mode": "fixed", "value": 0.5}

        cpu_time = self.benchmark_operation(cpu_op, large_image, params)
        metal_time = self.benchmark_operation(metal_op, large_image, params)

        speedup = cpu_time / metal_time

        print(
            f"\nCPU: {cpu_time:.2f}ms, Metal: {metal_time:.2f}ms, "
            f"Ratio: {speedup:.2f}x"
        )

        # Verify Metal produces results
        assert metal_time > 0, "Metal operation should complete"

    def test_full_chain_cpu_vs_gpu_vs_metal(self, xlarge_image: Image.Image) -> None:
        """Test full processing chain and document performance characteristics."""
        cpu_op = SaturationOperation()
        gpu_op = SaturationGPUOperation()
        metal_op = SaturationMetalOperation()

        params = {"mode": "fixed", "value": 0.5}

        cpu_time = self.benchmark_operation(cpu_op, xlarge_image, params, iterations=3)
        gpu_time = self.benchmark_operation(gpu_op, xlarge_image, params, iterations=3)
        metal_time = self.benchmark_operation(
            metal_op, xlarge_image, params, iterations=3
        )

        print(
            f"\nFull chain on 4K image:\n"
            f"  CPU:   {cpu_time:.2f}ms\n"
            f"  GPU:   {gpu_time:.2f}ms ({cpu_time/gpu_time:.2f}x)\n"
            f"  Metal: {metal_time:.2f}ms ({cpu_time/metal_time:.2f}x)"
        )
        print(
            "\nNote: PIL's implementation is faster for this operation due to:\n"
            "  - Highly optimized C code with SIMD\n"
            "  - No memory transfer overhead\n"
            "  - Simple operation (9 FLOPs) where transfer dominates"
        )

        # Verify all implementations produce results
        assert cpu_time > 0 and gpu_time > 0 and metal_time > 0

        # Metal should be competitive with GPU (both have similar overhead)
        assert abs(metal_time - gpu_time) / min(metal_time, gpu_time) < 0.3, (
            f"Metal ({metal_time:.2f}ms) and GPU ({gpu_time:.2f}ms) "
            "should have similar performance"
        )

    def test_numerical_accuracy_gpu_vs_cpu(self, large_image: Image.Image) -> None:
        """Test GPU and CPU produce nearly identical results (machine epsilon)."""
        cpu_op = SaturationOperation()
        gpu_op = SaturationGPUOperation()

        params = {"mode": "fixed", "value": 0.5}

        cpu_result = cpu_op.apply(large_image, params)
        gpu_result = gpu_op.apply(large_image, params)

        cpu_array = np.array(cpu_result, dtype=np.float32)
        gpu_array = np.array(gpu_result, dtype=np.float32)

        # Calculate differences
        max_diff = np.max(np.abs(cpu_array - gpu_array))
        mean_diff = np.mean(np.abs(cpu_array - gpu_array))

        print(
            f"\nGPU vs CPU numerical accuracy: "
            f"max_diff={max_diff:.2f}, mean_diff={mean_diff:.2f}"
        )

        # Results should be very close (allowing for floating point differences)
        # HSV conversion can have small rounding differences
        assert max_diff < 2.0, f"Max difference {max_diff} too large"
        assert mean_diff < 0.5, f"Mean difference {mean_diff} too large"

    def test_numerical_accuracy_metal_vs_cpu(self, large_image: Image.Image) -> None:
        """Test Metal and CPU produce nearly identical results (machine epsilon)."""
        cpu_op = SaturationOperation()
        metal_op = SaturationMetalOperation()

        params = {"mode": "fixed", "value": 0.5}

        cpu_result = cpu_op.apply(large_image, params)
        metal_result = metal_op.apply(large_image, params)

        cpu_array = np.array(cpu_result, dtype=np.float32)
        metal_array = np.array(metal_result, dtype=np.float32)

        max_diff = np.max(np.abs(cpu_array - metal_array))
        mean_diff = np.mean(np.abs(cpu_array - metal_array))

        print(
            f"\nMetal vs CPU numerical accuracy: "
            f"max_diff={max_diff:.2f}, mean_diff={mean_diff:.2f}"
        )

        # Results should be very close (allowing for floating point differences)
        assert max_diff < 2.0, f"Max difference {max_diff} too large"
        assert mean_diff < 0.5, f"Mean difference {mean_diff} too large"

    def test_numerical_accuracy_metal_vs_gpu(self, large_image: Image.Image) -> None:
        """Test Metal and GPU produce nearly identical results (machine epsilon)."""
        gpu_op = SaturationGPUOperation()
        metal_op = SaturationMetalOperation()

        params = {"mode": "fixed", "value": 0.5}

        gpu_result = gpu_op.apply(large_image, params)
        metal_result = metal_op.apply(large_image, params)

        gpu_array = np.array(gpu_result, dtype=np.float32)
        metal_array = np.array(metal_result, dtype=np.float32)

        max_diff = np.max(np.abs(gpu_array - metal_array))
        mean_diff = np.mean(np.abs(gpu_array - metal_array))

        print(
            f"\nMetal vs GPU numerical accuracy: "
            f"max_diff={max_diff:.2f}, mean_diff={mean_diff:.2f}"
        )

        # GPU and Metal should use identical kernels, so differences should be minimal
        assert max_diff < 1.0, f"Max difference {max_diff} too large"
        assert mean_diff < 0.1, f"Mean difference {mean_diff} too large"

    def test_grayscale_conversion_accuracy(self) -> None:
        """Test machine epsilon accuracy for grayscale conversion."""
        # Create test image with known values
        test_image = Image.new("RGB", (1000, 1000), color=(150, 100, 50))

        cpu_op = SaturationOperation()
        gpu_op = SaturationGPUOperation()
        metal_op = SaturationMetalOperation()

        # Convert to complete grayscale
        params = {"mode": "fixed", "value": -1.0}

        cpu_result = cpu_op.apply(test_image, params)
        gpu_result = gpu_op.apply(test_image, params)
        metal_result = metal_op.apply(test_image, params)

        cpu_array = np.array(cpu_result, dtype=np.float32)
        gpu_array = np.array(gpu_result, dtype=np.float32)
        metal_array = np.array(metal_result, dtype=np.float32)

        # All should produce grayscale (R == G == B)
        for name, arr in [
            ("CPU", cpu_array),
            ("GPU", gpu_array),
            ("Metal", metal_array),
        ]:
            r_g_diff = np.max(np.abs(arr[:, :, 0] - arr[:, :, 1]))
            g_b_diff = np.max(np.abs(arr[:, :, 1] - arr[:, :, 2]))
            assert r_g_diff < 2.0, f"{name}: R-G channels differ by {r_g_diff}"
            assert g_b_diff < 2.0, f"{name}: G-B channels differ by {g_b_diff}"

        # Compare implementations
        gpu_cpu_diff = np.mean(np.abs(gpu_array - cpu_array))
        metal_cpu_diff = np.mean(np.abs(metal_array - cpu_array))

        print(
            f"\nGrayscale accuracy: "
            f"GPU-CPU={gpu_cpu_diff:.4f}, Metal-CPU={metal_cpu_diff:.4f}"
        )

        assert gpu_cpu_diff < 0.5, f"GPU-CPU grayscale diff {gpu_cpu_diff} too large"
        assert (
            metal_cpu_diff < 0.5
        ), f"Metal-CPU grayscale diff {metal_cpu_diff} too large"

    def test_saturation_boost_accuracy(self) -> None:
        """Test machine epsilon accuracy for saturation boost."""
        # Create colorful test image
        test_image = Image.new("RGB", (1000, 1000), color=(200, 100, 50))

        cpu_op = SaturationOperation()
        gpu_op = SaturationGPUOperation()
        metal_op = SaturationMetalOperation()

        # Boost saturation significantly
        params = {"mode": "fixed", "value": 1.0}

        cpu_result = cpu_op.apply(test_image, params)
        gpu_result = gpu_op.apply(test_image, params)
        metal_result = metal_op.apply(test_image, params)

        cpu_array = np.array(cpu_result, dtype=np.float32)
        gpu_array = np.array(gpu_result, dtype=np.float32)
        metal_array = np.array(metal_result, dtype=np.float32)

        # Compare implementations
        gpu_cpu_diff = np.mean(np.abs(gpu_array - cpu_array))
        metal_cpu_diff = np.mean(np.abs(metal_array - cpu_array))
        metal_gpu_diff = np.mean(np.abs(metal_array - gpu_array))

        print(
            f"\nSaturation boost accuracy: "
            f"GPU-CPU={gpu_cpu_diff:.4f}, Metal-CPU={metal_cpu_diff:.4f}, "
            f"Metal-GPU={metal_gpu_diff:.4f}"
        )

        # Allow small differences due to HSV conversion floating point math
        assert gpu_cpu_diff < 1.0, f"GPU-CPU diff {gpu_cpu_diff} too large"
        assert metal_cpu_diff < 1.0, f"Metal-CPU diff {metal_cpu_diff} too large"
        assert metal_gpu_diff < 0.5, f"Metal-GPU diff {metal_gpu_diff} too large"
